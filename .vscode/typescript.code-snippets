{
  "Heap": {
    "scope": "typescript",
    "prefix": "Heap",
    "body": [
      "type Comparator<T> = (a: T, b: T) => number;",
      "",
      "export class Heap<T> {",
      "  protected heap: T[] = [];",
      "  private comparator: Comparator<T>;",
      "",
      "  constructor(comparator: Comparator<T>) {",
      "    this.comparator = comparator;",
      "  }",
      "",
      "  static heapify<T>(arr: Array<T>, comparator: Comparator<T>): Heap<T> {",
      "    const heap = new Heap(comparator);",
      "    heap.heap = [...arr];",
      "",
      "    for (let i = Math.floor((arr.length - 1) / 2); i >= 0; i--) {",
      "      heap.heapifyDownFrom(i);",
      "    }",
      "",
      "    return heap;",
      "  }",
      "",
      "  isEmpty() {",
      "    return this.heap.length === 0;",
      "  }",
      "",
      "  clear() {",
      "    this.heap = [];",
      "  }",
      "",
      "  peek(): T | null {",
      "    return this.isEmpty() ? null : this.heap[0];",
      "  }",
      "",
      "  private swap(idx: number, jdx: number): void {",
      "    [this.heap[idx], this.heap[jdx]] = [this.heap[jdx], this.heap[idx]];",
      "  }",
      "",
      "  push(val: T): void {",
      "    this.heap.push(val);",
      "    this.heapifyUp();",
      "  }",
      "",
      "  private heapifyUp(): void {",
      "    let idx = this.heap.length - 1;",
      "    while (",
      "      Math.floor((idx - 1) / 2) >= 0 && this.comparator(",
      "          this.heap[Math.floor((idx - 1) / 2)],",
      "          this.heap[idx],",
      "        ) > 0",
      "    ) {",
      "      this.swap(Math.floor((idx - 1) / 2), idx);",
      "      idx = Math.floor((idx - 1) / 2);",
      "    }",
      "  }",
      "",
      "  pop(): T | null {",
      "    if (this.isEmpty()) {",
      "      return null;",
      "    } else {",
      "      this.swap(0, this.heap.length - 1);",
      "      const popped = this.heap.pop()!;",
      "      this.heapifyDown();",
      "      return popped;",
      "    }",
      "  }",
      "",
      "  private heapifyDown(): void {",
      "    this.heapifyDownFrom(0);",
      "  }",
      "",
      "  private heapifyDownFrom(idx: number): void {",
      "    while (idx * 2 + 1 < this.heap.length) {",
      "      let smallerChildIdx = idx * 2 + 1;",
      "",
      "      if (",
      "        idx * 2 + 2 < this.heap.length &&",
      "        this.comparator(this.heap[idx * 2 + 2], this.heap[idx * 2 + 1]) < 0",
      "      ) {",
      "        smallerChildIdx = idx * 2 + 2;",
      "      }",
      "",
      "      if (this.comparator(this.heap[idx], this.heap[smallerChildIdx]) < 0) {",
      "        break;",
      "      }",
      "",
      "      this.swap(idx, smallerChildIdx);",
      "      idx = smallerChildIdx;",
      "    }",
      "  }",
      "}"
    ],
    "description": "Heap"
  },
  "function main stdin": {
    "prefix": "main",
    "body": [
      "import * as readline from \"readline\";",
      "",
      "async function main() {",
      "  const rl = readline.createInterface({",
      "    input: process.stdin,",
      "    terminal: false,",
      "  });",
      "",
      "  const iterator = rl[Symbol.asyncIterator]();",
      "",
      "  const readLine = async () => {",
      "    const { value } = await iterator.next();",
      "    return value;",
      "  };",
      "",
      "  const T = parseInt(await readLine(), 10);",
      "}",
      ""
    ],
    "description": "function main stdin"
  }
}
